Contents:
1.) Setup (PLEASE READ)
2.) Intended audience
3.) Validation tests (optional)
4.) Coding conventions
5.) Examples (PLEASE READ)
6.) Development history
7.) TODO's

________________________________________________________________________________

                            1.) Setup
________________________________________________________________________________

Speclab does *not* work out of the box. You have to run one function beforehand,
aptly named 'setup.m'. This file is located in the base directory of the Speclab
bundle. You can just cd into the directory in Matlab, and run

>> setup;

Depending on what your directory structure is set up like, setup might make some
comments about ignoring directories. Setup should terminate with some
nice-sounding message(s) about successfully doing things. 

Speclab is now set up and ready for use. In the course of your computations, if
you ever run 'clear all' or 'clear global' then *you will have to run setup
again*.  

PLEASE READ THE EXAMPLES SECTION IN THIS FILE BEFORE PROCEEDING TO USE SPECLAB.

Optional reading:

setup.m does two things:
1.) Creates a Matlab-global variable called 'handles'. handles is a nested
    struct whose tree-like structure mimics Speclab's directory structure. Each
    node of the tree corresponds to an m-file function inside Speclab. In this
    way, functions in e.g. the Fourier side of Speclab can access functions in
    the Jacobi polynomial section of Speclab without needing to do messy things
    like changing directories or adding a bunch of directories to Matlab's PATH
    variable, thereby polluting the command line namespace. As mentioned before,
    if you happen to clear this global variable, you'll have to run setup.m
    again to rewrite it. You can inspect handles yourself by typing

    >> global handles

    at the command line. And then inspecting the variable.

2.) Regrettably...adds some directories to Matlab's PATH variable. However, the
    only directories it adds are those associated with class declarations.
    Function names are not introduced into the global path at all, only class
    names.  

    Class names are declared in the FirstLetterUppercase format. Functions are
    declared in the all_lowercase_underscore_separation format. This rubric is
    (hopefully) consistent across Speclab. 

________________________________________________________________________________

                            2.) Intended audience
________________________________________________________________________________

Speclab is intended for those familiar with spectral expansions of various
types. It can also be used by those who are in the process of learning about
spectral approximations from a different source. It is meant to be a tool used
for quick implementation to test something out, or a sandbox to try out some
ideas. 

Speclab is NOT meant to
- have commercial-grade speed. This is Matlab, after all. If you want something
  faster, write and compile code.
- be a tutorial for those wholly unfamiliar with spectral expansions
________________________________________________________________________________

                            3.) Validation Tests
________________________________________________________________________________

Once setup.m is run, Speclab is ready to go. However, for peace of mind, it
might be beneficial to run the Speclab validation tests. Running these tests can
take up to 5 minutes, but generally only take 2 minutes or so. 

>> setup;
>> global handles
>> handles.debug.all_tests();

This runs a bunch (~400) of tests with some relatively well-formatted output.
The test parameters are randomized, so it's not a big deal if a dozen or so of
the tests fail. I haven't gotten around to tweaking the randomness to ensure
success. 

NOTE: As of this writing, Speclab does *not* require class/object-oriented
support in Matlab to work. (That will change in the future.) However, running
the validation tests *does* require classes. The validation tests should run
with Matlab version >= 7.6 (R2008a). For lower versions, Matlab will probably
return a slew of errors. 

________________________________________________________________________________
                            
                            4.) Coding conventions
________________________________________________________________________________

Throughout Speclab, the following coding conventions are used. 

All function names use the lowercase_verbose_underscore_separated_naming
convention. This does not relieve one from typing a long name, but does remove
the problem of figuring out what onemrsqxp.m does. Instead, it will say
one_minus_r_squared_times_p.m, which is much easier to figure out.

Classes are not yet (really) built into Speclab yet. When they are, class names
will use the AllUppercaseNoSpacing format. Again, not necessarily short, but
effective at getting the point across and differentiating from function names. 

Each m-file has a (hopefully) descriptive helpstring. In Matlab, you can cd into
the directory containing file.m and type "help file" and it will print the
helpstring. However, functions in Speclab are usually called via a function
handle and not by changing directories (see section 1). Matlab's help function
does not recognize what to do with function handles, so unfortunately you have
to take the roundabout way of getting help:
If you want help for the function with handle
handles.speclab.fourier.affine_scaling, you can type at the command line:
>> handles.helper('speclab', 'fourier', 'affine_scaling')
I.e., just use the same tree structure split into strings as multiple inputs
into the function handles.helper. 

Most m-files take optional arguments. Rather than deal with things like "if
nargin<=5 elseif nargin>3..." I've decided to use something akin to Matlab's
InputParser. However, the way InputParser works is not very transparent to me,
and it's new enough that I feel like Mathworks might change conventions on me.
Therefore, I've written handles.common.InputSchema, which does two things:
- conspicuously breaks the aforementioned convention that function_names will
  have a certain format :( (on a TODO list for a future release)
- essentially does the same thing as InputParser but works very transparently
  with structs.  InputSchema handles almost all optional input arguments in
  Speclab. (There are some exceptions when I avoid calling InputSchema because
  it saves a bit of run-time.)
In helpstrings, optional inputs are given in curly {} brackets. See
speclab/examples/chebyshev/intro.m on how to call functions with optional
arguments.

There are some files strewn about Speclab that are named something like
function_name_.m. Notice the extra underscore "_" before the extension .m. This
underscore at the end denotes that this is a deprecated/in-progress file and you
should not rely on it; I haven't tested such files at all. 

________________________________________________________________________________
                            
                            5.) Examples
________________________________________________________________________________

All examples are contained in the speclab/examples folder. All examples are
script m-files with code and comments to describe what is going on.  You should
be able to jump to whatever expansion you care about and start running those
examples. However, it is *highly recommended* that you go through the Chebyshev
examples first (speclab/examples/chebyshev). The Chebyshev example files
contain comments that describe the gist of how to run things in Speclab
including helpstring format, parameter inputs, general structure of a spectral
expansion. 

The other expansion examples do not go into such wordy detail in the comments
and assume you know how to do basic things in Speclab. Other README files in the
examples folder with some not-so-detailed specifics about expansions:

-- speclab/examples/chebyshev/README
-- speclab/examples/legendre/README
-- speclab/examples/jacobi/README
-- speclab/examples/fourier/README
-- speclab/examples/wiener/README

________________________________________________________________________________
                            
                            6.) Development history
________________________________________________________________________________

If you'd like the whole development history for Speclab, you'll need the
open-source "distributed version control system" called "git". 

Once you have git installed. Open up a command line, and do the following:
1.) Decide what directory you'd like to install this stuff in. For this example,
    I'll call this directory mfiles.
2.) Run "git clone git://github.com/cygnine/CommonMatlab.git mfiles"
3.) Run "cd mfiles"
4.) Run "git clone git://github.com/cygnine/speclab.git"

There are two git repositories: the "CommonMatlab" one handles all things not
related to (but used by) Speclab. Speclab has it's own git repository and
history. 

You may navigate a web browser to 
- http://www.github.com/cygnine/CommonMatlab
- http://www.github.com/cygnine/speclab
and github will show a pretty GUI of the development history and included files.
You can also download a tarball directly from github of each repo, but the
tarball won't have the history. 

________________________________________________________________________________
                            
                            7.) TODO's
________________________________________________________________________________

- Hermite polynomial/function expansions
- Sinc expansions
- mapped methods
- filters
- object-oriented implementation. This will increase user-friendliness a great
  deal. It will also standardize calling syntax.
- fast 'special function' zero calculations a la Glaser & Rohklin.
